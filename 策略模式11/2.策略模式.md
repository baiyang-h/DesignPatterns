### 策略模式

------



#### 简单运用

策略模式指的是定义一系列的算法，把他们一个个封装起来。

将不变的部分和变化的部分隔开是每个设计模式的主题，策略模式也不例外，策略模式的目的就是将算法的使用与算法的实现分离开来。

一个基于策略模式的程序至少由两部分组成。第一部分是一组策略类，策略类封装了具体的算法，并负责具体的计算过程。第二部分是环境类Context，Context接受客户的请求，随后把请求委托给某一个策略类。要做到这点，说明Context中要维持对某个策略对象的引用。

- 不同策略分开处理
- 避免大量的`if else`、`switch case`

例子：

```js
class User {
  constructor(type) {
    this.type = type;
  }
  buy() {
    if(this.type === "A") {
      console.log("A")
    } 
    else if (this.type === "B") {
      console.log("B")
    }
    else if (this.type === "C") {
      console.log("C")
    }
  }
}

let u1 = new User("A");
u1.buy();
let u2 = new User("B");
u2.buy();
let u3 = new User("C");
u3.buy();
```

改为策略模式

```js
class User1 {
  buy() {
    console.log("A")
  }
}
class User2 {
  buy() {
    console.log("B")
  }
}
class User3 {
  buy() {
    console.log("C")
  }
}
let u1 = new User("A");
u1.buy();
let u2 = new User("B");
u2.buy();
let u3 = new User("C");
u3.buy();
```

策略模式就是要将各自的算法和算法的实现分离开来。



#### JavaScript版本的策略模式

```js
//各自的算法
const user = {
  A() {
    console.log("A")
  },
  B() {
    console.log("B")
  },
  C() {
    console.log("C")
  },
}
//算法的实现
const buy = function(key) {
  user[key]()
}
buy('A')
buy('B')
buy('C')
```

总结：**不同策略，分开处理，而不是混在一起使用**。



#### 表单校验的例子

在没有引入策略模式的情况：

```html
<form action="#" id="registerForm" method="post"> 
  请输入用户名:<input type="text" name="userName"/>
  请输入密码:<input type="text" name="password"/>
  请输入手机号码:<input type="text" name="phoneNumber"/>
  <button>提交</button>
</form>
```

```js
var registerForm = document.getElementById('registerForm');
registerForm.onsubmit = function() {
  if(registerForm.userName.value === '') {
    alert('用户名不能为空');
    return false;
  }
  if(registerForm.password.value.length < 6) {
    alert('密码长度不能少于6位');
    return false;
  }
  if(!/^1[358][0-9]{9}$/.test(registerForm.phoneNumber.value)) {
    alert('手机号码格式不正确');
    return false;
  }
}
```

这是一种很常见的代码编写方式，它的缺点是：

- `registerForm.onsubmit`函数比较庞大，包含了很多`if-else`语句，这些语句需要覆盖所有的校验规则
- `registerForm.onsubmit`函数缺乏弹性，如果增加了一种新的校验规则，或者想把密码的长度校验从6改为8，我们都必须深入`registerForm.onsubmit`函数的内部实现，这是违反开放-封闭原则的。
- 算法的复用性差，如果在程序中增加了另外一个表单，这个表单也需要进行一些类似的校验，那我们很可能将这些校验逻辑复制的漫天遍野。

##### 用策略模式重构表单校验

```html
<form action="#" id="registerForm" method="post">
  请输入用户名:<input type="text" name="userName" /><br>
  请输入密码:<input type="text" name="password" /><br>
  请输入手机号码:<input type="text" name="phoneNumber" /><br>
  <button>提交</button>
</form>
```

```js
//校验规则
var strategies = {
  isNonEmpty(value, errorMsg) {
    if (value === '') return errorMsg;
  },
  minLength(value, length, errorMsg) {
    if (value.length < length) return errorMsg;
  },
  isMobile(value, errorMsg) {
    if (!/^1[358][0-9]{9}$/.test(value)) return errorMsg;
  }
}

class Validator {
  constructor() {
    this.cache = []; //保存校验规则
  }
  //用于将各自的规则传入cache
  add(dom, rule, errorMsg) {
    var ary = rule.split(':');      //把strategy和参数分开
    this.cache.push(function () {   //把校验的步骤用空函数包装起来，并且放入 cache
      var strategy = ary.shift(); // 用户挑选的 strategy
      ary.unshift(dom.value);     //把 input 的 value 添加进参数列表
      ary.push(errorMsg);         //把errorMsg 添加进参数列表
      return strategies[strategy].apply(dom, ary)
    })
  }
  //执行所有规则，找到不符合规则的返回
  start() {
    for (var i = 0, validatorFunc; validatorFunc = this.cache[i++];) {
      var msg = validatorFunc(); // 开始校验，并取得校验后的返回信息
      if (msg) { // 如果有确切的返回值，说明校验没有通过
        return msg;
      }
    }
  }
}

var validataFunc = function () {
  var validator = new Validator(); 		//创建一个validator对象
  /********添加一些校验规则**********/
  validator.add(registerForm.userName, 'isNonEmpty', '用户名不能为空');
  validator.add(registerForm.password, 'minLength:6', '密码长度不能少于 6 位');
  validator.add(registerForm.phoneNumber, 'isMobile', '手机号码格式不正确');

  var errorMsg = validator.start(); //获得校验结果
  return errorMsg; 									//返回校验结果
}

var registerForm = document.getElementById('registerForm');
registerForm.onsubmit = function () {
  var errorMsg = validataFunc(); 	//如果errorMsg有确切的返回值，说明未通过校验
  if (errorMsg) {
    alert(errorMsg);
    return false; 	//阻止表单提交
  }
}
```

Validator 类在这里作为 Context，负责接收用户的请求并委托给 strategy 对象。

使用策略模式重构代码之后，我们仅仅通过“配置”的方式就可以完成一个表单的校验，这些校验规则也可以复用在程序的任何地方，还能作为插件的形式，方便地被移植到其他项目中。

在修改某个校验规则的时候，只需要编写或者改写少量的代码。比如：

```js
validator.add( registerForm.userName, 'minLength:10', '用户名长度不能小于 10 位' );
```

##### 给某个文本输入框添加多种校验规则

目前我们的表单校验实现留有一点小遗憾:一个文本输入框只能对应一种校验规则，比如，用户名输入框只能校验输入是否为空：

如果我们既想校验它是否为空，又想校验它输入文本的长度不小于 10 呢？我们期望以这样的形式进行校验：

```js
validator.add(registerForm.userName, [{
  strategy: 'isNonEmpty',
  errorMsg: '用户名不能为空'
}, {
  strategy: 'minLength:6',
  errorMsg: '用户名长度不能小于 10 位'
}]);
```

结果：

```js
/***********************策略对象**************************/
var strategies = {
  isNonEmpty(value, errorMsg) {
    if (value === '') return errorMsg;
  },
  minLength(value, length, errorMsg) {
    if (value.length < length) return errorMsg;
  },
  isMobile(value, errorMsg) {
    if (!/^1[358][0-9]{9}$/.test(value)) return errorMsg;
  }
}
/***********************Validator 类**************************/
class Validator {
  constructor() {
    this.cache = [];
  }
  add(dom, rules) {
    var self = this;
    for (var i = 0, rule; rule = rules[i++];) {
      (function (rule) {
        var strategyAry = rule.strategy.split(':');
        var errorMsg = rule.errorMsg;
        self.cache.push(function () {
          var strategy = strategyAry.shift();
          strategyAry.unshift(dom.value);
          strategyAry.push(errorMsg);
          return strategies[strategy].apply(dom, strategyAry);
        });
      })(rule)
    }
  }
  start() {
    for (var i = 0, validatorFunc; validatorFunc = this.cache[i++];) {
      var errorMsg = validatorFunc();
      if (errorMsg) {
        return errorMsg;
      }
    }
  }
}
/***********************客户调用代码**************************/
var validataFunc = function () {
  var validator = new Validator();
  // validator.add(registerForm.userName, 'isNonEmpty', '用户名不能为空');

  validator.add(registerForm.userName, [{
    strategy: 'isNonEmpty',
    errorMsg: '用户名不能为空'
  }, {
    strategy: 'minLength:6',
    errorMsg: '用户名长度不能小于 10 位'
  }]);
  validator.add(registerForm.password, [{
    strategy: 'minLength:6',
    errorMsg: '密码长度不能小于 6 位'
  }]);
  validator.add(registerForm.phoneNumber, [{
    strategy: 'isMobile',
    errorMsg: '手机号码格式不正确'
  }]);

  var errorMsg = validator.start();
  return errorMsg;
}
var registerForm = document.getElementById('registerForm');
registerForm.onsubmit = function () {
  var errorMsg = validataFunc();
  if (errorMsg) {
    alert(errorMsg);
    return false;
  }
}
```

